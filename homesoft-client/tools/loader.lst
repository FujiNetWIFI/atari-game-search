mads 2.1.1
Source: loader.s
     1 				        opt h-
     2 				        org $03FD
     3
     4 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
     5 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
     6 = 02E7			MEMLO   =   $02E7       ; MEM LO
     7 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
     8
     9 = 0300			DCB     =   $0300       ; BASE
    10 = 0300			DDEVIC  =   DCB         ; DEVICE #
    11 = 0301			DUNIT   =   DCB+1       ; UNIT #
    12 = 0302			DCOMND  =   DCB+2       ; COMMAND
    13 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    14 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    15 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    16 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    17 = 0307			DRSVD   =   DCB+7       ; NOT USED
    18 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    19 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    20 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    21 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    22
    23 = E459			SIOV    =   $E459               ; SIO VECTOR
    24 = 0088			EOF     =   136
    25 				        
    26 				     
    27 				        .ENUM   DCB_IDX
    28 				                                ;---------------
    29 = 0000			        DDEVIC              ; 0
    30 = 0001			        DUNIT               ; 1
    31 = 0002			        DCOMND              ; 2
    32 = 0003			        DSTATS              ; 3
    33 = 0004			        DBUFL               ; 4
    34 = 0005			        DBUFH               ; 5
    35 = 0006			        DTIMLO              ; 6
    36 = 0007			        DRESVD              ; 7
    37 = 0008			        DBYTL               ; 8
    38 = 0009			        DBYTH               ; 9
    39 = 000A			        DAUX1               ; 10
    40 = 000B			        DAUX2               ; 11
    41 				        .ENDE
    42
    43 				        .MACRO DCBC
    44 				        .LOCAL
    45 				        LDY     #$0C
    46 				        ?DCBL   LDA     %%1,Y
    47 				        STA     DCB,Y
    48 				        DEY
    49 				        BPL     ?DCBL
    50 				        .ENDL
    51 				        .ENDM
    52
    53 03FD 4C 44 04			JMP	DO_LOAD
    54
    55 0400 71			STADCB: .BYTE   $71      ; DDEVIC
    56 0401 01			        .BYTE   $01         ; DUNIT
    57 0402 53			        .BYTE   'S'         ; DCOMND
    58 0403 40			        .BYTE   $40         ; DSTATS
    59 0404 EA			        .BYTE   <DVSTAT     ; DBUFL
    60 0405 02			        .BYTE   >DVSTAT     ; DBUFH
    61 0406 0F			        .BYTE   $0F         ; DTIMLO
    62 0407 00			        .BYTE   $00         ; DRESVD
    63 0408 04			        .BYTE   $04         ; DBYTL
    64 0409 00			        .BYTE   $00         ; DBYTH
    65 040A 00			        .BYTE   $00         ; DAUX1
    66 040B 00			        .BYTE   $00         ; DAUX2
    67
    68 				                                ; Copy command's template DCB struct to OS's DCB struct (12 bytes)
    69 040C			DOSIOV:
    70 040C 8D 15 04		        STA     DODCBL+1
    71 040F 8C 16 04		        STY     DODCBL+2
    72 				                                ;        LDY     #$0C
    73 0412 A0 0B		        LDY     #$0B
    74 0414 B9 FF FF		DODCBL  LDA     $FFFF,Y
    75 0417 99 00 03		        STA     DCB,Y
    76 041A 88			        DEY
    77 041B 10 F7		        BPL     DODCBL
    78
    79 041D			SIOVDST:
    80 041D 20 59 E4		        JSR     SIOV
    81 0420 AC 03 03		        LDY     DSTATS
    82 0423 98			        TYA
    83 0424 60			        RTS
    84
    85 0425 71			CLODCB .BYTE     $71      ; DDEVIC
    86 0426 01			        .BYTE    $01         ; DUNIT
    87 0427 43			        .BYTE    'C'         ; DCOMND
    88 0428 00			        .BYTE    $00         ; DSTATS
    89 0429 00			        .BYTE    $00         ; DBUFL
    90 042A 00			        .BYTE    $00         ; DBUFH
    91 042B 0F			        .BYTE    $0F         ; DTIMLO
    92 042C 00			        .BYTE    $00         ; DRESVD
    93 042D 00			        .BYTE    $00         ; DBYTL
    94 042E 00			        .BYTE    $00         ; DBYTH
    95 042F 00			        .BYTE    $00         ; DAUX1
    96 0430 00			        .BYTE    $00         ; DAUX2
    97
    98 				        ;; Loader borrowed from NOS. Thank you, Michael.
    99 				        ;; self-modifying memclear borrowed from MaPa
   100
   101 0431			CLEAR_MENU:    
   102 0431 A9 00		    	lda #0
   103 0433 A2 00		    	ldx #0
   104 0435 A0 B8		    	ldy #$b8
   105 0437 9D 00 07		cloop 	sta $0700,x
   106 043A E8			    	inx
   107 043B D0 FA		    	bne cloop
   108 043D EE 39 04		    	inc cloop+2  ; increasing HI-byte of the clearing address
   109 0440 88			    	dey
   110 0441 D0 F4		    	bne cloop
   111 0443 60				RTS
   112
   113 0444			DO_LOAD:
   114 0444 20 31 04		        JSR     CLEAR_MENU
   115 0447 20 8A 04		        JSR     LOAD_SETUP
   116 044A A9 FF		        LDA     #$FF
   117 044C 8D 6C 06		        STA     BIN_1ST
   118 044F 20 A0 04		        JSR     LOAD_READ2
   119 0452 20 C1 04		        JSR     LOAD_CHKFF
   120 0455 C0 01		        CPY     #$01
   121 0457 D0 30		        BNE     R
   122
   123 0459 EE 6C 06		        INC     BIN_1ST
   124 				    ; Process each payload
   125 045C 20 A0 04		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
   126 045F 30 28		        BMI     R               ; Exit if EOF hit
   127 0461 20 95 04		        JSR     LOAD_INIT       ; Set init default
   128 0464 A2 01		        LDX     #$01
   129 0466 20 C1 04		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
   130 0469 20 DF 04		        JSR     LOAD_STRAD      ; Put start address in
   131 046C 20 A0 04		        JSR     LOAD_READ2      ; Get to more butes (end addr)
   132 046F 20 EC 04		        JSR     LOAD_ENDAD      ; Put end address in
   133 0472 20 05 05		        JSR     LOAD_BUFLEN     ; Calculate buffer length
   134 0475 20 2A 05		        JSR     LOAD_GETDAT     ; Get the data record
   135 0478 10 03		        BPL     @+              ; Was EOF detected?
   136 047A 20 86 04		        JSR     JSTART          ; Yes. Go to RUNAD
   137 047D 20 83 04		@:      JSR     JINIT           ; Attempt initialization
   138 0480 4C 5C 04		        JMP     GETFIL          ; Process next payload
   139
   140 0483 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
   141 0486 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
   142 0489 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
   143
   144 				;---------------------------------------
   145 048A			LOAD_SETUP:
   146 				;---------------------------------------
   147 048A A9 89		        LDA     #<R
   148 048C 8D E0 02		        STA     RUNAD
   149 048F A9 04		        LDA     #>R
   150 0491 8D E1 02		        STA     RUNAD+1
   151 0494 60			        RTS
   152
   153 				;---------------------------------------
   154 0495			LOAD_INIT:
   155 				;---------------------------------------
   156 0495 A9 89		        LDA     #<R
   157 0497 8D E2 02		        STA     INITAD
   158 049A A9 04		        LDA     #>R
   159 049C 8D E3 02		        STA     INITAD+1
   160 049F 60			        RTS
   161
   162 				;---------------------------------------
   163 04A0			LOAD_READ2:
   164 				;---------------------------------------
   165
   166 				    ;---------------------------------------
   167 				    ; This is accomplished by abusing the LOAD_GETDAT
   168 				    ; routine by stuffing the buffer addr (BAL/H)
   169 				    ; into the payload Start/End addrs. We're doing
   170 				    ; this in case a payload  header straddles a
   171 				    ; cache boundary. LOAD_GETDAT has the logic for
   172 				    ; dealing with that.
   173 				    ;---------------------------------------
   174 04A0 A9 5A		        LDA     #<BAL
   175 04A2 8D 5C 06		        STA     STL         ; Payload start address
   176 04A5 A9 06		        LDA     #>BAL
   177 04A7 8D 5D 06		        STA     STH
   178
   179 04AA A9 5B		        LDA     #<BAH
   180 04AC 8D 5E 06		        STA     ENL         ; Payload end address
   181 04AF A9 06		        LDA     #>BAH
   182 04B1 8D 5F 06		        STA     ENH
   183
   184 04B4 A2 02		        LDX     #$02
   185 04B6 8E 64 06		        STX     BLL         ; Payload size (2)
   186 04B9 A9 00		        LDA     #$00
   187 04BB 8D 65 06		        STA     BLH
   188
   189 04BE 4C 2A 05		        JMP     LOAD_GETDAT ; Read 2 bytes
   190
   191 				;---------------------------------------
   192 04C1			LOAD_CHKFF:
   193 				;---------------------------------------
   194 				    ; On 1st pass, check for binary signature (FF FF)
   195 				    ; On 2..n passes, Skip FF FF (if found)
   196 				    ; and read next 2 bytes
   197 				    ;---------------------------------------
   198
   199 04C1 A9 FF		        LDA     #$FF
   200 04C3 CD 5A 06		        CMP     BAL         ; Is 1st byte FF?
   201 04C6 D0 0D		        BNE     NOTFF       ; If no, skip down.
   202 04C8 CD 5B 06		        CMP     BAH         ; Is 2nd byte FF?
   203 04CB D0 08		        BNE     NOTFF       ; If no, skip down.
   204
   205 				    ;---------------------------------------
   206 				    ; Here if FF FF tags found.
   207 				    ; On 1st pass, we're done.
   208 				    ; On 2..n passes, read next 2 bytes and leave.
   209 				    ;---------------------------------------
   210 04CD CD 6C 06		        CMP     BIN_1ST     ; Is this 1st pass?
   211 04D0 F0 0C		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
   212 04D2 4C A0 04		        JMP     LOAD_READ2  ;
   213
   214 				    ;---------------------------------------
   215 				    ; Here if FF FF tags NOT found.
   216 				    ; On 1st pass, print error.
   217 				    ; On 2..n passes, the 2 bytes = payload start addr.
   218 				    ;---------------------------------------
   219 04D5 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
   220 04D7 CD 6C 06		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
   221 04DA D0 02		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
   222
   223 04DC A0 FF		        LDY     #$FF        ; Return failure
   224 04DE			NOTFF_DONE:
   225 04DE 60			        RTS
   226
   227 				;---------------------------------------
   228 04DF			LOAD_STRAD:
   229 				;---------------------------------------
   230 				    ; Save payload start address into STL2/STLH2.
   231 				    ; Otherwise it will get clobbered
   232 				    ; when reading payload end address.
   233 04DF AD 5A 06		        LDA     BAL
   234 04E2 8D 6A 06		        STA     STL2
   235 04E5 AD 5B 06		        LDA     BAH
   236 04E8 8D 6B 06		        STA     STH2
   237 04EB 60			        RTS
   238
   239 				;---------------------------------------
   240 04EC			LOAD_ENDAD:
   241 				;---------------------------------------
   242 				    ; Save payload end address
   243 04EC AD 6A 06		        LDA     STL2
   244 04EF 8D 5C 06		        STA     STL
   245 04F2 AD 6B 06		        LDA     STH2
   246 04F5 8D 5D 06		        STA     STH
   247
   248 04F8 AD 5A 06		        LDA     BAL
   249 04FB 8D 5E 06		        STA     ENL
   250 04FE AD 5B 06		        LDA     BAH
   251 0501 8D 5F 06		        STA     ENH
   252 0504 60			        RTS
   253
   254 				;---------------------------------------
   255 0505			LOAD_BUFLEN:
   256 				;---------------------------------------
   257 				    ; Calculate buffer length (end-start+1)
   258
   259 				    ; Calc buffer size Lo
   260 0505 AD 5E 06		        LDA     ENL
   261 0508 38			        SEC
   262 0509 ED 5C 06		        SBC     STL
   263 050C 8D 64 06		        STA     BLL     ; Buffer Length Lo
   264
   265 				    ; Calc buffer size Hi
   266 050F AD 5F 06		        LDA     ENH     ; Calc buffer size Hi
   267 0512 ED 5D 06		        SBC     STH
   268 0515 8D 65 06		        STA     BLH     ; Buffer Length Hi
   269
   270 				    ; Add 1
   271 0518 18			        CLC
   272 0519 AD 64 06		        LDA     BLL
   273 051C 69 01		        ADC     #$01
   274 051E 8D 64 06		        STA     BLL
   275
   276 0521 AD 65 06		        LDA     BLH
   277 0524 69 00		        ADC     #$00    ; Take care of any carry
   278 0526 8D 65 06		        STA     BLH
   279
   280 0529 60			        RTS
   281
   282 				;---------------------------------------
   283 052A			LOAD_GETDAT:
   284 				;---------------------------------------
   285 				    ; Definitions:
   286 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
   287 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
   288 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
   289
   290 052A 20 23 06		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
   291 052D 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
   292 052F 60			        RTS
   293
   294 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
   295 0530			GETDAT_NEXT1:
   296 0530 AD EA 02		        LDA     DVSTAT
   297 0533 CD 64 06		        CMP     BLL
   298 0536 AD EB 02		        LDA     DVSTAT+1
   299 0539 ED 65 06		        SBC     BLH
   300 053C B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
   301
   302 053E			GETDAT_OPT1:
   303 				    ;--------------------------------
   304 				    ; Here if bytes requested > bytes
   305 				    ; remaining in cache
   306 				    ;--------------------------------
   307
   308 				    ;-------------------------------
   309 				    ; Head = BW (bytes waiting)
   310 				    ;-------------------------------
   311 053E AD EA 02		        LDA     DVSTAT
   312 0541 8D 60 06		        STA     HEADL
   313 0544 AD EB 02		        LDA     DVSTAT+1
   314 0547 8D 61 06		        STA     HEADH
   315
   316 				    ;-------------------------------
   317 				    ; Tail = (BL - HEAD) mod 512
   318 				    ;-------------------------------
   319 054A 38			        SEC
   320 054B AD 64 06		        LDA     BLL
   321 054E ED 60 06		        SBC     HEADL
   322 0551 29 FF		        AND     #$FF
   323 0553 8D 66 06		        STA     TAILL
   324 0556 AD 65 06		        LDA     BLH
   325 0559 ED 61 06		        SBC     HEADH
   326 055C 29 01		        AND     #$01
   327 055E 8D 67 06		        STA     TAILH
   328
   329 				    ;-----------------------------------
   330 				    ; Body = BL - HEAD - TAIL
   331 				    ;-----------------------------------
   332 				        ; 1. Body = BL - HEAD
   333 				        ;-------------------------------
   334 0561 38			        SEC
   335 0562 AD 64 06		        LDA     BLL
   336 0565 ED 60 06		        SBC     HEADL
   337 0568 8D 62 06		        STA     BODYL
   338 056B AD 65 06		        LDA     BLH
   339 056E ED 61 06		        SBC     HEADH
   340 0571 8D 63 06		        STA     BODYH
   341
   342 				        ;-------------------------------
   343 				        ; 2. Body = Body - HEAD
   344 				        ;-------------------------------
   345 0574 38			        SEC
   346 0575 AD 62 06		        LDA     BODYL
   347 0578 ED 66 06		        SBC     TAILL
   348 057B 8D 62 06		        STA     BODYL
   349 057E AD 63 06		        LDA     BODYH
   350 0581 ED 67 06		        SBC     TAILH
   351 0584 8D 63 06		        STA     BODYH
   352
   353 0587 4C A4 05		        JMP     GETDAT_READ
   354
   355 058A			GETDAT_OPT2:
   356 				    ;--------------------------------
   357 				    ; Here if bytes requested <= bytes
   358 				    ; remaining in cache
   359 				    ;--------------------------------
   360 				    ; Head = BL, TAIL = BODY = 0
   361 				    ;--------------------------------
   362 058A AD 64 06		        LDA     BLL
   363 058D 8D 60 06		        STA     HEADL
   364 0590 AD 65 06		        LDA     BLH
   365 0593 8D 61 06		        STA     HEADH
   366 0596 A9 00		        LDA     #$00
   367 0598 8D 66 06		        STA     TAILL
   368 059B 8D 67 06		        STA     TAILH
   369 059E 8D 62 06		        STA     BODYL
   370 05A1 8D 63 06		        STA     BODYH
   371
   372 				;---------------------------------------
   373 05A4			GETDAT_READ:
   374 				;---------------------------------------
   375 				    ;---------------------------------------
   376 				    ; Read HEAD bytes
   377 				    ;---------------------------------------
   378 05A4 AD 60 06		        LDA     HEADL
   379 05A7 8D 64 06		        STA     BLL
   380 05AA AD 61 06		        LDA     HEADH
   381 05AD 8D 65 06		        STA     BLH
   382 05B0 20 E1 05		        JSR     GETDAT_DOSIOV
   383 05B3 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
   384 05B5 60			        RTS                 ; Bail if error
   385
   386 				    ;---------------------------------------
   387 				    ; Read BODY bytes
   388 				    ;---------------------------------------
   389 05B6			GETDAT_BODY:
   390 05B6 AE 63 06		        LDX     BODYH
   391 05B9			GETDAT_BODY_LOOP:
   392 05B9 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
   393
   394 05BB A9 00		        LDA     #$00
   395 05BD 8D 64 06		        STA     BLL         ; Buffer length
   396 05C0 A9 02		        LDA     #$02        ; 512 bytes at a time
   397 05C2 8D 65 06		        STA     BLH
   398
   399 05C5 8A			        TXA                 ; Stash our loop index (X)
   400 05C6 48			        PHA                 ; onto the stack
   401 05C7 20 E1 05		        JSR     GETDAT_DOSIOV
   402 05CA 10 03		        BPL     @+          ; Skip ahead if no problems
   403 05CC 68			        PLA                 ; Here if problem. Clean up stack
   404 05CD 98			        TYA                 ; Reset N status flag before returning
   405 05CE 60			        RTS                 ; Bail if error
   406
   407 05CF 68			@:      PLA                 ; Retrieve our loop index
   408 05D0 AA			        TAX                 ; and xfer it back into X
   409 05D1 CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
   410 05D2 CA			        DEX                 ;
   411 05D3 D0 E4		        BNE     GETDAT_BODY_LOOP
   412
   413 05D5			GETDAT_TAIL:
   414 				    ;---------------------------------------
   415 				    ; Read TAIL bytes
   416 				    ;---------------------------------------
   417 05D5 AD 66 06		        LDA     TAILL
   418 05D8 8D 64 06		        STA     BLL
   419 05DB AD 67 06		        LDA     TAILH
   420 05DE 8D 65 06		        STA     BLH
   421
   422 				;---------------------------------------
   423 05E1			GETDAT_DOSIOV:
   424 				;---------------------------------------
   425 				    ; Bail if BL = 0
   426 05E1 AD 64 06		        LDA     BLL
   427 05E4 D0 05		        BNE     @+
   428 05E6 AD 65 06		        LDA     BLH
   429 05E9 F0 59		        BEQ     CHECK_EOF_DONE
   430
   431 05EB			@:
   432 				    ; SIO READ
   433 05EB AD 5C 06		        LDA     STL
   434 05EE 8D 4B 06		        STA     BINDCB+DCB_IDX.DBUFL    ; Start Address Lo
   435 05F1 AD 5D 06		        LDA     STH
   436 05F4 8D 4C 06		        STA     BINDCB+DCB_IDX.DBUFH    ; Start Address Hi
   437 05F7 AD 64 06		        LDA     BLL
   438 05FA 8D 4F 06		        STA     BINDCB+DCB_IDX.DBYTL    ; Buffer Size Lo
   439 05FD 8D 51 06		        STA     BINDCB+DCB_IDX.DAUX1
   440 0600 AD 65 06		        LDA     BLH
   441 0603 8D 50 06		        STA     BINDCB+DCB_IDX.DBYTH    ; Buffer Size Hi
   442 0606 8D 52 06		        STA     BINDCB+DCB_IDX.DAUX2
   443
   444 				    ;---------------------------------------
   445 				    ; Send Read request to SIO
   446 				    ;---------------------------------------
   447 0609 A9 47		        LDA     #<BINDCB
   448 060B A0 06		        LDY     #>BINDCB
   449 060D 20 0C 04		        JSR     DOSIOV
   450
   451 				    ;---------------------------------------
   452 				    ; Advance start address by buffer length
   453 				    ;---------------------------------------
   454 0610 18			        CLC
   455 0611 AD 5C 06		        LDA     STL
   456 0614 6D 64 06		        ADC     BLL
   457 0617 8D 5C 06		        STA     STL
   458
   459 061A AD 5D 06		        LDA     STH
   460 061D 6D 65 06		        ADC     BLH
   461 0620 8D 5D 06		        STA     STH
   462
   463 0623			GETDAT_CHECK_EOF:
   464 				    ; Get status (updates DVSTAT, DSTATS)
   465 0623 AD 48 06		        LDA     BINDCB+DCB_IDX.DUNIT
   466 0626 8D 01 04		        STA     STADCB+DCB_IDX.DUNIT
   467 0629 A9 00		        LDA     #<STADCB
   468 062B A0 04		        LDY     #>STADCB
   469 062D 20 0C 04		        JSR     DOSIOV
   470
   471 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
   472 0630 AD EA 02		        LDA     DVSTAT
   473 0633 D0 0F		        BNE     CHECK_EOF_DONE
   474
   475 0635 AD EB 02		        LDA     DVSTAT+1
   476 0638 D0 0A		        BNE     CHECK_EOF_DONE
   477
   478 063A A9 88		        LDA     #EOF
   479 063C CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
   480 063F D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
   481 0641 A0 FF		        LDY     #$FF            ; Yes? Return -1
   482 0643 60			        RTS
   483
   484 0644			CHECK_EOF_DONE:
   485 0644 A0 01		        LDY     #$01        ; Return success
   486 0646 60			        RTS
   487
   488 0647			BINDCB:
   489 0647 71			       .BYTE    $71      ; DDEVIC
   490 0648 01			       .BYTE    $01         ; DUNIT
   491 0649 52			       .BYTE    'R'         ; DCOMND
   492 064A 40			       .BYTE    $40         ; DSTATS
   493 064B FF			       .BYTE    $FF         ; DBUFL
   494 064C FF			       .BYTE    $FF         ; DBUFH
   495 064D 0F			       .BYTE    $0F         ; DTIMLO
   496 064E 00			       .BYTE    $00         ; DRESVD
   497 064F FF			       .BYTE    $FF         ; DBYTL
   498 0650 FF			       .BYTE    $FF         ; DBYTH
   499 0651 FF			       .BYTE    $FF         ; DAUX1
   500 0652 FF			       .BYTE    $FF         ; DAUX2
   501
   502 				;---------------------------------------
   503 0653			LOAD_CLOSE:
   504 				;---------------------------------------
   505 0653 A9 25		        LDA     #<CLODCB
   506 0655 A0 04		        LDY     #>CLODCB
   507 0657 4C 0C 04		        JMP     DOSIOV
   508
   509 				                                ; Binary loader working variables
   510 = 065A			BAL     .ds 1
   511 = 065B			BAH     .ds 1    ;
   512 = 065C			STL     .ds 1      ; Payload Start address
   513 = 065D			STH     .ds 1
   514 = 065E			ENL     .ds 1    ; Payload End address
   515 = 065F			ENH     .ds 1
   516 = 0660			HEADL   .ds 1    ; Bytes read from existing cache
   517 = 0661			HEADH   .ds 1
   518 = 0662			BODYL   .ds 1    ; Total bytes read in contiguous 512-byte blocks
   519 = 0663			BODYH   .ds 1
   520 = 0664			BLL     .ds 1    ; Payload Buffer Length
   521 = 0665			BLH     .ds 1
   522 = 0666			TAILL   .ds 1   ; Bytes read from last cache
   523 = 0667			TAILH   .ds 1
   524 = 0668			BODYSZL .ds 1   ; # Bytes to read at a time in Body
   525 = 0669			BODYSZH .ds 1
   526 = 066A			STL2    .ds 1   ; Payload Start address (working var)
   527 = 066B			STH2    .ds 1
   528 = 066C			BIN_1ST .ds 1   ; Flag for binary loader signature (FF -> 1st pass)
   529 = 066D			TMP1    .ds 1
   530 = 066E			TMP2    .ds 1
   531 				        
