mads 2.1.1
Source: loader.s
     1 				        opt h-
     2 				        org $03FD
     3
     4 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
     5 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
     6 = 02E7			MEMLO   =   $02E7       ; MEM LO
     7 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
     8
     9 = 0300			DCB     =   $0300       ; BASE
    10 = 0300			DDEVIC  =   DCB         ; DEVICE #
    11 = 0301			DUNIT   =   DCB+1       ; UNIT #
    12 = 0302			DCOMND  =   DCB+2       ; COMMAND
    13 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    14 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    15 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    16 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    17 = 0307			DRSVD   =   DCB+7       ; NOT USED
    18 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    19 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    20 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    21 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    22
    23 = E459			SIOV    =   $E459               ; SIO VECTOR
    24 = 0088			EOF     =   136
    25 				        ;; Put DCBs in the stack.
    26 = 0120			STADCB  =   $0120
    27 = 012C			CLODCB  =   $012C
    28 = 0138			BINDCB  =   $0138        
    29 				        ;; Put utility functions in stack, check loader-stack.lst.
    30 = 0144			CLEAR_MENU = $0144
    31 = 0157			LOAD_SETUP = $0157
    32 = 0162			LOAD_INIT  = $0162
    33 = 016D			DOSIOV     = $016D
    34 = 0186			LOAD_CLOSE = $0186        
    35
    36 				        .ENUM   DCB_IDX
    37 				                                ;---------------
    38 = 0000			        DDEVIC              ; 0
    39 = 0001			        DUNIT               ; 1
    40 = 0002			        DCOMND              ; 2
    41 = 0003			        DSTATS              ; 3
    42 = 0004			        DBUFL               ; 4
    43 = 0005			        DBUFH               ; 5
    44 = 0006			        DTIMLO              ; 6
    45 = 0007			        DRESVD              ; 7
    46 = 0008			        DBYTL               ; 8
    47 = 0009			        DBYTH               ; 9
    48 = 000A			        DAUX1               ; 10
    49 = 000B			        DAUX2               ; 11
    50 				        .ENDE
    51
    52 				        .MACRO DCBC
    53 				        .LOCAL
    54 				        LDY     #$0C
    55 				        ?DCBL   LDA     %%1,Y
    56 				        STA     DCB,Y
    57 				        DEY
    58 				        BPL     ?DCBL
    59 				        .ENDL
    60 				        .ENDM
    61
    62 				DO_LOAD:
    63 03FD 20 44 01		        JSR     CLEAR_MENU
    64 0400 20 57 01		        JSR     LOAD_SETUP
    65 0403 A9 FF		        LDA     #$FF
    66 0405 8D FC 05		        STA     BIN_1ST
    67 0408 20 43 04		        JSR     LOAD_READ2
    68 040B 20 64 04		        JSR     LOAD_CHKFF
    69 040E C0 01		        CPY     #$01
    70 0410 D0 30		        BNE     R
    71
    72 0412 EE FC 05		        INC     BIN_1ST
    73 				    ; Process each payload
    74 0415 20 43 04		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
    75 0418 30 28		        BMI     R               ; Exit if EOF hit
    76 041A 20 62 01		        JSR     LOAD_INIT       ; Set init default
    77 041D A2 01		        LDX     #$01
    78 041F 20 64 04		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
    79 0422 20 82 04		        JSR     LOAD_STRAD      ; Put start address in
    80 0425 20 43 04		        JSR     LOAD_READ2      ; Get to more butes (end addr)
    81 0428 20 8F 04		        JSR     LOAD_ENDAD      ; Put end address in
    82 042B 20 A8 04		        JSR     LOAD_BUFLEN     ; Calculate buffer length
    83 042E 20 CD 04		        JSR     LOAD_GETDAT     ; Get the data record
    84 0431 10 03		        BPL     @+              ; Was EOF detected?
    85 0433 20 3F 04		        JSR     JSTART          ; Yes. Go to RUNAD
    86 0436 20 3C 04		@:      JSR     JINIT           ; Attempt initialization
    87 0439 4C 15 04		        JMP     GETFIL          ; Process next payload
    88
    89 043C 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
    90 043F 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
    91 0442 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
    92
    93 				;---------------------------------------
    94 0443			LOAD_READ2:
    95 				;---------------------------------------
    96
    97 				    ;---------------------------------------
    98 				    ; This is accomplished by abusing the LOAD_GETDAT
    99 				    ; routine by stuffing the buffer addr (BAL/H)
   100 				    ; into the payload Start/End addrs. We're doing
   101 				    ; this in case a payload  header straddles a
   102 				    ; cache boundary. LOAD_GETDAT has the logic for
   103 				    ; dealing with that.
   104 				    ;---------------------------------------
   105 0443 A9 EA		        LDA     #<BAL
   106 0445 8D EC 05		        STA     STL         ; Payload start address
   107 0448 A9 05		        LDA     #>BAL
   108 044A 8D ED 05		        STA     STH
   109
   110 044D A9 EB		        LDA     #<BAH
   111 044F 8D EE 05		        STA     ENL         ; Payload end address
   112 0452 A9 05		        LDA     #>BAH
   113 0454 8D EF 05		        STA     ENH
   114
   115 0457 A2 02		        LDX     #$02
   116 0459 8E F4 05		        STX     BLL         ; Payload size (2)
   117 045C A9 00		        LDA     #$00
   118 045E 8D F5 05		        STA     BLH
   119
   120 0461 4C CD 04		        JMP     LOAD_GETDAT ; Read 2 bytes
   121
   122 				;---------------------------------------
   123 0464			LOAD_CHKFF:
   124 				;---------------------------------------
   125 				    ; On 1st pass, check for binary signature (FF FF)
   126 				    ; On 2..n passes, Skip FF FF (if found)
   127 				    ; and read next 2 bytes
   128 				    ;---------------------------------------
   129
   130 0464 A9 FF		        LDA     #$FF
   131 0466 CD EA 05		        CMP     BAL         ; Is 1st byte FF?
   132 0469 D0 0D		        BNE     NOTFF       ; If no, skip down.
   133 046B CD EB 05		        CMP     BAH         ; Is 2nd byte FF?
   134 046E D0 08		        BNE     NOTFF       ; If no, skip down.
   135
   136 				    ;---------------------------------------
   137 				    ; Here if FF FF tags found.
   138 				    ; On 1st pass, we're done.
   139 				    ; On 2..n passes, read next 2 bytes and leave.
   140 				    ;---------------------------------------
   141 0470 CD FC 05		        CMP     BIN_1ST     ; Is this 1st pass?
   142 0473 F0 0C		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
   143 0475 4C 43 04		        JMP     LOAD_READ2  ;
   144
   145 				    ;---------------------------------------
   146 				    ; Here if FF FF tags NOT found.
   147 				    ; On 1st pass, print error.
   148 				    ; On 2..n passes, the 2 bytes = payload start addr.
   149 				    ;---------------------------------------
   150 0478 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
   151 047A CD FC 05		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
   152 047D D0 02		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
   153
   154 047F A0 FF		        LDY     #$FF        ; Return failure
   155 0481			NOTFF_DONE:
   156 0481 60			        RTS
   157
   158 				;---------------------------------------
   159 0482			LOAD_STRAD:
   160 				;---------------------------------------
   161 				    ; Save payload start address into STL2/STLH2.
   162 				    ; Otherwise it will get clobbered
   163 				    ; when reading payload end address.
   164 0482 AD EA 05		        LDA     BAL
   165 0485 8D FA 05		        STA     STL2
   166 0488 AD EB 05		        LDA     BAH
   167 048B 8D FB 05		        STA     STH2
   168 048E 60			        RTS
   169
   170 				;---------------------------------------
   171 048F			LOAD_ENDAD:
   172 				;---------------------------------------
   173 				    ; Save payload end address
   174 048F AD FA 05		        LDA     STL2
   175 0492 8D EC 05		        STA     STL
   176 0495 AD FB 05		        LDA     STH2
   177 0498 8D ED 05		        STA     STH
   178
   179 049B AD EA 05		        LDA     BAL
   180 049E 8D EE 05		        STA     ENL
   181 04A1 AD EB 05		        LDA     BAH
   182 04A4 8D EF 05		        STA     ENH
   183 04A7 60			        RTS
   184
   185 				;---------------------------------------
   186 04A8			LOAD_BUFLEN:
   187 				;---------------------------------------
   188 				    ; Calculate buffer length (end-start+1)
   189
   190 				    ; Calc buffer size Lo
   191 04A8 AD EE 05		        LDA     ENL
   192 04AB 38			        SEC
   193 04AC ED EC 05		        SBC     STL
   194 04AF 8D F4 05		        STA     BLL     ; Buffer Length Lo
   195
   196 				    ; Calc buffer size Hi
   197 04B2 AD EF 05		        LDA     ENH     ; Calc buffer size Hi
   198 04B5 ED ED 05		        SBC     STH
   199 04B8 8D F5 05		        STA     BLH     ; Buffer Length Hi
   200
   201 				    ; Add 1
   202 04BB 18			        CLC
   203 04BC AD F4 05		        LDA     BLL
   204 04BF 69 01		        ADC     #$01
   205 04C1 8D F4 05		        STA     BLL
   206
   207 04C4 AD F5 05		        LDA     BLH
   208 04C7 69 00		        ADC     #$00    ; Take care of any carry
   209 04C9 8D F5 05		        STA     BLH
   210
   211 04CC 60			        RTS
   212
   213 				;---------------------------------------
   214 04CD			LOAD_GETDAT:
   215 				;---------------------------------------
   216 				    ; Definitions:
   217 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
   218 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
   219 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
   220
   221 04CD 20 C6 05		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
   222 04D0 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
   223 04D2 60			        RTS
   224
   225 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
   226 04D3			GETDAT_NEXT1:
   227 04D3 AD EA 02		        LDA     DVSTAT
   228 04D6 CD F4 05		        CMP     BLL
   229 04D9 AD EB 02		        LDA     DVSTAT+1
   230 04DC ED F5 05		        SBC     BLH
   231 04DF B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
   232
   233 04E1			GETDAT_OPT1:
   234 				    ;--------------------------------
   235 				    ; Here if bytes requested > bytes
   236 				    ; remaining in cache
   237 				    ;--------------------------------
   238
   239 				    ;-------------------------------
   240 				    ; Head = BW (bytes waiting)
   241 				    ;-------------------------------
   242 04E1 AD EA 02		        LDA     DVSTAT
   243 04E4 8D F0 05		        STA     HEADL
   244 04E7 AD EB 02		        LDA     DVSTAT+1
   245 04EA 8D F1 05		        STA     HEADH
   246
   247 				    ;-------------------------------
   248 				    ; Tail = (BL - HEAD) mod 512
   249 				    ;-------------------------------
   250 04ED 38			        SEC
   251 04EE AD F4 05		        LDA     BLL
   252 04F1 ED F0 05		        SBC     HEADL
   253 04F4 29 FF		        AND     #$FF
   254 04F6 8D F6 05		        STA     TAILL
   255 04F9 AD F5 05		        LDA     BLH
   256 04FC ED F1 05		        SBC     HEADH
   257 04FF 29 01		        AND     #$01
   258 0501 8D F7 05		        STA     TAILH
   259
   260 				    ;-----------------------------------
   261 				    ; Body = BL - HEAD - TAIL
   262 				    ;-----------------------------------
   263 				        ; 1. Body = BL - HEAD
   264 				        ;-------------------------------
   265 0504 38			        SEC
   266 0505 AD F4 05		        LDA     BLL
   267 0508 ED F0 05		        SBC     HEADL
   268 050B 8D F2 05		        STA     BODYL
   269 050E AD F5 05		        LDA     BLH
   270 0511 ED F1 05		        SBC     HEADH
   271 0514 8D F3 05		        STA     BODYH
   272
   273 				        ;-------------------------------
   274 				        ; 2. Body = Body - HEAD
   275 				        ;-------------------------------
   276 0517 38			        SEC
   277 0518 AD F2 05		        LDA     BODYL
   278 051B ED F6 05		        SBC     TAILL
   279 051E 8D F2 05		        STA     BODYL
   280 0521 AD F3 05		        LDA     BODYH
   281 0524 ED F7 05		        SBC     TAILH
   282 0527 8D F3 05		        STA     BODYH
   283
   284 052A 4C 47 05		        JMP     GETDAT_READ
   285
   286 052D			GETDAT_OPT2:
   287 				    ;--------------------------------
   288 				    ; Here if bytes requested <= bytes
   289 				    ; remaining in cache
   290 				    ;--------------------------------
   291 				    ; Head = BL, TAIL = BODY = 0
   292 				    ;--------------------------------
   293 052D AD F4 05		        LDA     BLL
   294 0530 8D F0 05		        STA     HEADL
   295 0533 AD F5 05		        LDA     BLH
   296 0536 8D F1 05		        STA     HEADH
   297 0539 A9 00		        LDA     #$00
   298 053B 8D F6 05		        STA     TAILL
   299 053E 8D F7 05		        STA     TAILH
   300 0541 8D F2 05		        STA     BODYL
   301 0544 8D F3 05		        STA     BODYH
   302
   303 				;---------------------------------------
   304 0547			GETDAT_READ:
   305 				;---------------------------------------
   306 				    ;---------------------------------------
   307 				    ; Read HEAD bytes
   308 				    ;---------------------------------------
   309 0547 AD F0 05		        LDA     HEADL
   310 054A 8D F4 05		        STA     BLL
   311 054D AD F1 05		        LDA     HEADH
   312 0550 8D F5 05		        STA     BLH
   313 0553 20 84 05		        JSR     GETDAT_DOSIOV
   314 0556 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
   315 0558 60			        RTS                 ; Bail if error
   316
   317 				    ;---------------------------------------
   318 				    ; Read BODY bytes
   319 				    ;---------------------------------------
   320 0559			GETDAT_BODY:
   321 0559 AE F3 05		        LDX     BODYH
   322 055C			GETDAT_BODY_LOOP:
   323 055C F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
   324
   325 055E A9 00		        LDA     #$00
   326 0560 8D F4 05		        STA     BLL         ; Buffer length
   327 0563 A9 02		        LDA     #$02        ; 512 bytes at a time
   328 0565 8D F5 05		        STA     BLH
   329
   330 0568 8A			        TXA                 ; Stash our loop index (X)
   331 0569 48			        PHA                 ; onto the stack
   332 056A 20 84 05		        JSR     GETDAT_DOSIOV
   333 056D 10 03		        BPL     @+          ; Skip ahead if no problems
   334 056F 68			        PLA                 ; Here if problem. Clean up stack
   335 0570 98			        TYA                 ; Reset N status flag before returning
   336 0571 60			        RTS                 ; Bail if error
   337
   338 0572 68			@:      PLA                 ; Retrieve our loop index
   339 0573 AA			        TAX                 ; and xfer it back into X
   340 0574 CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
   341 0575 CA			        DEX                 ;
   342 0576 D0 E4		        BNE     GETDAT_BODY_LOOP
   343
   344 0578			GETDAT_TAIL:
   345 				    ;---------------------------------------
   346 				    ; Read TAIL bytes
   347 				    ;---------------------------------------
   348 0578 AD F6 05		        LDA     TAILL
   349 057B 8D F4 05		        STA     BLL
   350 057E AD F7 05		        LDA     TAILH
   351 0581 8D F5 05		        STA     BLH
   352
   353 				;---------------------------------------
   354 0584			GETDAT_DOSIOV:
   355 				;---------------------------------------
   356 				    ; Bail if BL = 0
   357 0584 AD F4 05		        LDA     BLL
   358 0587 D0 05		        BNE     @+
   359 0589 AD F5 05		        LDA     BLH
   360 058C F0 59		        BEQ     CHECK_EOF_DONE
   361
   362 058E			@:
   363 				    ; SIO READ
   364 058E AD EC 05		        LDA     STL
   365 0591 8D 3C 01		        STA     BINDCB+DCB_IDX.DBUFL    ; Start Address Lo
   366 0594 AD ED 05		        LDA     STH
   367 0597 8D 3D 01		        STA     BINDCB+DCB_IDX.DBUFH    ; Start Address Hi
   368 059A AD F4 05		        LDA     BLL
   369 059D 8D 40 01		        STA     BINDCB+DCB_IDX.DBYTL    ; Buffer Size Lo
   370 05A0 8D 42 01		        STA     BINDCB+DCB_IDX.DAUX1
   371 05A3 AD F5 05		        LDA     BLH
   372 05A6 8D 41 01		        STA     BINDCB+DCB_IDX.DBYTH    ; Buffer Size Hi
   373 05A9 8D 43 01		        STA     BINDCB+DCB_IDX.DAUX2
   374
   375 				    ;---------------------------------------
   376 				    ; Send Read request to SIO
   377 				    ;---------------------------------------
   378 05AC A9 38		        LDA     #<BINDCB
   379 05AE A0 01		        LDY     #>BINDCB
   380 05B0 20 6D 01		        JSR     DOSIOV
   381
   382 				    ;---------------------------------------
   383 				    ; Advance start address by buffer length
   384 				    ;---------------------------------------
   385 05B3 18			        CLC
   386 05B4 AD EC 05		        LDA     STL
   387 05B7 6D F4 05		        ADC     BLL
   388 05BA 8D EC 05		        STA     STL
   389
   390 05BD AD ED 05		        LDA     STH
   391 05C0 6D F5 05		        ADC     BLH
   392 05C3 8D ED 05		        STA     STH
   393
   394 05C6			GETDAT_CHECK_EOF:
   395 				    ; Get status (updates DVSTAT, DSTATS)
   396 05C6 AD 39 01		        LDA     BINDCB+DCB_IDX.DUNIT
   397 05C9 8D 21 01		        STA     STADCB+DCB_IDX.DUNIT
   398 05CC A9 20		        LDA     #<STADCB
   399 05CE A0 01		        LDY     #>STADCB
   400 05D0 20 6D 01		        JSR     DOSIOV
   401
   402 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
   403 05D3 AD EA 02		        LDA     DVSTAT
   404 05D6 D0 0F		        BNE     CHECK_EOF_DONE
   405
   406 05D8 AD EB 02		        LDA     DVSTAT+1
   407 05DB D0 0A		        BNE     CHECK_EOF_DONE
   408
   409 05DD A9 88		        LDA     #EOF
   410 05DF CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
   411 05E2 D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
   412 05E4 A0 FF		        LDY     #$FF            ; Yes? Return -1
   413 05E6 60			        RTS
   414
   415 05E7			CHECK_EOF_DONE:
   416 05E7 A0 01		        LDY     #$01        ; Return success
   417 05E9 60			        RTS
   418
   419 				                                ; Binary loader working variables
   420 = 05EA			BAL     .ds 1
   421 = 05EB			BAH     .ds 1    ;
   422 = 05EC			STL     .ds 1      ; Payload Start address
   423 = 05ED			STH     .ds 1
   424 = 05EE			ENL     .ds 1    ; Payload End address
   425 = 05EF			ENH     .ds 1
   426 = 05F0			HEADL   .ds 1    ; Bytes read from existing cache
   427 = 05F1			HEADH   .ds 1
   428 = 05F2			BODYL   .ds 1    ; Total bytes read in contiguous 512-byte blocks
   429 = 05F3			BODYH   .ds 1
   430 = 05F4			BLL     .ds 1    ; Payload Buffer Length
   431 = 05F5			BLH     .ds 1
   432 = 05F6			TAILL   .ds 1   ; Bytes read from last cache
   433 = 05F7			TAILH   .ds 1
   434 = 05F8			BODYSZL .ds 1   ; # Bytes to read at a time in Body
   435 = 05F9			BODYSZH .ds 1
   436 = 05FA			STL2    .ds 1   ; Payload Start address (working var)
   437 = 05FB			STH2    .ds 1
   438 = 05FC			BIN_1ST .ds 1   ; Flag for binary loader signature (FF -> 1st pass)
   439 				        
